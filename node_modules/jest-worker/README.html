<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="jest-worker">jest-worker</h1>
<p>Module for executing heavy tasks under forked processes in parallel, by providing a <code>Promise</code> based interface, minimum overhead, and bound workers.</p>
<p>The module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be <code>await</code>’ed. Child (worker) methods can either be synchronous or asynchronous.</p>
<p>The module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the <code>computeWorkerKey</code> method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a <code>computeWorkerKey</code> method because you want <em>some</em> of the tasks to be sticked, you can return <code>null</code> from it.</p>
<p>The list of exposed methods can be explicitly provided via the <code>exposedMethods</code> option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the “minimal example” section for a valid one.</p>
<h2 id="install">Install</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1">$ <span class="ex">yarn</span> add jest-worker</a></code></pre></div>
<h2 id="example">Example</h2>
<p>This example covers the minimal usage:</p>
<h3 id="file-parent.js">File <code>parent.js</code></h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="im">import</span> Worker <span class="im">from</span> <span class="st">&#39;jest-worker&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">async</span> <span class="kw">function</span> <span class="at">main</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="kw">const</span> worker <span class="op">=</span> <span class="kw">new</span> <span class="at">Worker</span>(<span class="va">require</span>.<span class="at">resolve</span>(<span class="st">&#39;./Worker&#39;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="kw">const</span> result <span class="op">=</span> <span class="cf">await</span> <span class="va">worker</span>.<span class="at">hello</span>(<span class="st">&#39;Alice&#39;</span>)<span class="op">;</span> <span class="co">// &quot;Hello, Alice&quot;</span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="at">main</span>()<span class="op">;</span></a></code></pre></div>
<h3 id="file-worker.js">File <code>worker.js</code></h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="im">export</span> <span class="kw">function</span> <span class="at">hello</span>(param) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="cf">return</span> <span class="st">&#39;Hello, &#39;</span> <span class="op">+</span> param<span class="op">;</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="op">}</span></a></code></pre></div>
<h2 id="experimental-worker">Experimental worker</h2>
<p>Node 10 shipped with <a href="https://nodejs.org/api/worker_threads.html">worker-threads</a>, a “threading API” that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in <code>jest-worker</code>.</p>
<p>Since <code>worker_threads</code> are considered experimental in Node, you have to opt-in to this behavior by passing <code>enableWorkerThreads: true</code> when instantiating the worker. While the feature was unflagged in Node 11.7.0, you’ll need to run the Node process with the <code>--experimental-worker</code> flag for Node 10.</p>
<h2 id="api">API</h2>
<p>The only exposed method is a constructor (<code>Worker</code>) that is initialized by passing the worker path, plus an options object.</p>
<h3 id="workerpath-string-required"><code>workerPath: string</code> (required)</h3>
<p>Node module name or absolute path of the file to be loaded in the child processes. Use <code>require.resolve</code> to transform a relative path into an absolute one.</p>
<h3 id="options-object-optional"><code>options: Object</code> (optional)</h3>
<h4 id="exposedmethods-readonlyarraystring-optional"><code>exposedMethods: $ReadOnlyArray&lt;string&gt;</code> (optional)</h4>
<p>List of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public <code>Worker</code> method, or starting with <code>_</code>. If you use method auto-discovery, then these methods will not be exposed, even if they exist.</p>
<h4 id="numworkers-number-optional"><code>numWorkers: number</code> (optional)</h4>
<p>Amount of workers to spawn. Defaults to the number of CPUs minus 1.</p>
<h4 id="maxretries-number-optional"><code>maxRetries: number</code> (optional)</h4>
<p>Maximum amount of times that a dead child can be re-spawned, per call. Defaults to <code>3</code>, pass <code>Infinity</code> to allow endless retries.</p>
<h4 id="forkoptions-object-optional"><code>forkOptions: Object</code> (optional)</h4>
<p>Allow customizing all options passed to <code>childProcess.fork</code>. By default, some values are set (<code>cwd</code>, <code>env</code> and <code>execArgv</code>), but you can override them and customize the rest. For a list of valid values, check <a href="https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options">the Node documentation</a>.</p>
<h4 id="computeworkerkey-method-string-...args-arrayany-string-optional"><code>computeWorkerKey: (method: string, ...args: Array&lt;any&gt;) =&gt; ?string</code> (optional)</h4>
<p>Every time a method exposed via the API is called, <code>computeWorkerKey</code> is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making <code>computeWorkerKey</code> return the same identifier for all different calls. If you do not want to bind the call to any worker, return <code>null</code>.</p>
<p>The callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the “bound worker usage” section.</p>
<p>By default, no process is bound to any worker.</p>
<h4 id="setupargs-arraymixed-optional"><code>setupArgs: Array&lt;mixed&gt;</code> (optional)</h4>
<p>The arguments that will be passed to the <code>setup</code> method during initialization.</p>
<h4 id="workerpool-workerpath-string-options-workerpooloptions-workerpoolinterface-optional"><code>workerPool: (workerPath: string, options?: WorkerPoolOptions) =&gt; WorkerPoolInterface</code> (optional)</h4>
<p>Provide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.</p>
<p>The arguments that will be passed to the <code>setup</code> method during initialization.</p>
<h4 id="enableworkerthreads-boolean-optional"><code>enableWorkerThreads: boolean</code> (optional)</h4>
<p><code>jest-worker</code> will automatically detect if <code>worker_threads</code> are available, but will not use them unless passed <code>enableWorkerThreads: true</code>.</p>
<h2 id="worker">Worker</h2>
<p>The returned <code>Worker</code> instance has all the exposed methods, plus some additional ones to interact with the workers itself:</p>
<h3 id="getstdout-readable"><code>getStdout(): Readable</code></h3>
<p>Returns a <code>ReadableStream</code> where the standard output of all workers is piped. Note that the <code>silent</code> option of the child workers must be set to <code>true</code> to make it work. This is the default set by <code>jest-worker</code>, but keep it in mind when overriding options through <code>forkOptions</code>.</p>
<h3 id="getstderr-readable"><code>getStderr(): Readable</code></h3>
<p>Returns a <code>ReadableStream</code> where the standard error of all workers is piped. Note that the <code>silent</code> option of the child workers must be set to <code>true</code> to make it work. This is the default set by <code>jest-worker</code>, but keep it in mind when overriding options through <code>forkOptions</code>.</p>
<h3 id="end"><code>end()</code></h3>
<p>Finishes the workers by killing all workers. No further calls can be done to the <code>Worker</code> instance.</p>
<p><strong>Note:</strong> Each worker has a unique id (index that starts with <code>1</code>) which is available on <code>process.env.JEST_WORKER_ID</code></p>
<h2 id="setting-up-and-tearing-down-the-child-process">Setting up and tearing down the child process</h2>
<p>The child process can define two special methods (both of them can be asynchronous):</p>
<ul>
<li><code>setup()</code>: If defined, it’s executed before the first call to any method in the child.</li>
<li><code>teardown()</code>: If defined, it’s executed when the farm ends.</li>
</ul>
<h1 id="more-examples">More examples</h1>
<h2 id="standard-usage">Standard usage</h2>
<p>This example covers the standard usage:</p>
<h3 id="file-parent.js-1">File <code>parent.js</code></h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="im">import</span> Worker <span class="im">from</span> <span class="st">&#39;jest-worker&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">async</span> <span class="kw">function</span> <span class="at">main</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="kw">const</span> myWorker <span class="op">=</span> <span class="kw">new</span> <span class="at">Worker</span>(<span class="va">require</span>.<span class="at">resolve</span>(<span class="st">&#39;./Worker&#39;</span>)<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="dt">exposedMethods</span><span class="op">:</span> [<span class="st">&#39;foo&#39;</span><span class="op">,</span> <span class="st">&#39;bar&#39;</span><span class="op">,</span> <span class="st">&#39;getWorkerId&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="dt">numWorkers</span><span class="op">:</span> <span class="dv">4</span><span class="op">,</span></a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-8" title="8"></a>
<a class="sourceLine" id="cb4-9" title="9">  <span class="va">console</span>.<span class="at">log</span>(<span class="cf">await</span> <span class="va">myWorker</span>.<span class="at">foo</span>(<span class="st">&#39;Alice&#39;</span>))<span class="op">;</span> <span class="co">// &quot;Hello from foo: Alice&quot;</span></a>
<a class="sourceLine" id="cb4-10" title="10">  <span class="va">console</span>.<span class="at">log</span>(<span class="cf">await</span> <span class="va">myWorker</span>.<span class="at">bar</span>(<span class="st">&#39;Bob&#39;</span>))<span class="op">;</span> <span class="co">// &quot;Hello from bar: Bob&quot;</span></a>
<a class="sourceLine" id="cb4-11" title="11">  <span class="va">console</span>.<span class="at">log</span>(<span class="cf">await</span> <span class="va">myWorker</span>.<span class="at">getWorkerId</span>())<span class="op">;</span> <span class="co">// &quot;3&quot; -&gt; this message has sent from the 3rd worker</span></a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13">  <span class="va">myWorker</span>.<span class="at">end</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="op">}</span></a>
<a class="sourceLine" id="cb4-15" title="15"></a>
<a class="sourceLine" id="cb4-16" title="16"><span class="at">main</span>()<span class="op">;</span></a></code></pre></div>
<h3 id="file-worker.js-1">File <code>worker.js</code></h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="im">export</span> <span class="kw">function</span> <span class="at">foo</span>(param) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="cf">return</span> <span class="st">&#39;Hello from foo: &#39;</span> <span class="op">+</span> param<span class="op">;</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="im">export</span> <span class="kw">function</span> <span class="at">bar</span>(param) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="cf">return</span> <span class="st">&#39;Hello from bar: &#39;</span> <span class="op">+</span> param<span class="op">;</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="im">export</span> <span class="kw">function</span> <span class="at">getWorkerId</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb5-10" title="10">  <span class="cf">return</span> <span class="va">process</span>.<span class="va">env</span>.<span class="at">JEST_WORKER_ID</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="op">}</span></a></code></pre></div>
<h2 id="bound-worker-usage">Bound worker usage:</h2>
<p>This example covers the usage with a <code>computeWorkerKey</code> method:</p>
<h3 id="file-parent.js-2">File <code>parent.js</code></h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="im">import</span> Worker <span class="im">from</span> <span class="st">&#39;jest-worker&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">async</span> <span class="kw">function</span> <span class="at">main</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="kw">const</span> myWorker <span class="op">=</span> <span class="kw">new</span> <span class="at">Worker</span>(<span class="va">require</span>.<span class="at">resolve</span>(<span class="st">&#39;./Worker&#39;</span>)<span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="dt">computeWorkerKey</span><span class="op">:</span> (method<span class="op">,</span> filename) <span class="kw">=&gt;</span> filename<span class="op">,</span></a>
<a class="sourceLine" id="cb6-6" title="6">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="co">// Transform the given file, within the first available worker.</span></a>
<a class="sourceLine" id="cb6-9" title="9">  <span class="va">console</span>.<span class="at">log</span>(<span class="cf">await</span> <span class="va">myWorker</span>.<span class="at">transform</span>(<span class="st">&#39;/tmp/foo.js&#39;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb6-10" title="10"></a>
<a class="sourceLine" id="cb6-11" title="11">  <span class="co">// Wait a bit.</span></a>
<a class="sourceLine" id="cb6-12" title="12">  <span class="cf">await</span> <span class="at">sleep</span>(<span class="dv">10000</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-13" title="13"></a>
<a class="sourceLine" id="cb6-14" title="14">  <span class="co">// Transform the same file again. Will immediately return because the</span></a>
<a class="sourceLine" id="cb6-15" title="15">  <span class="co">// transformed file is cached in the worker, and `computeWorkerKey` ensures</span></a>
<a class="sourceLine" id="cb6-16" title="16">  <span class="co">// the same worker that processed the file the first time will process it now.</span></a>
<a class="sourceLine" id="cb6-17" title="17">  <span class="va">console</span>.<span class="at">log</span>(<span class="cf">await</span> <span class="va">myWorker</span>.<span class="at">transform</span>(<span class="st">&#39;/tmp/foo.js&#39;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb6-18" title="18"></a>
<a class="sourceLine" id="cb6-19" title="19">  <span class="va">myWorker</span>.<span class="at">end</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb6-20" title="20"><span class="op">}</span></a>
<a class="sourceLine" id="cb6-21" title="21"></a>
<a class="sourceLine" id="cb6-22" title="22"><span class="at">main</span>()<span class="op">;</span></a></code></pre></div>
<h3 id="file-worker.js-2">File <code>worker.js</code></h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="im">import</span> babel <span class="im">from</span> <span class="st">&#39;@babel/core&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">const</span> cache <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(<span class="kw">null</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-4" title="4"></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="im">export</span> <span class="kw">function</span> <span class="at">transform</span>(filename) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="cf">if</span> (cache[filename]) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="cf">return</span> cache[filename]<span class="op">;</span></a>
<a class="sourceLine" id="cb7-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb7-9" title="9"></a>
<a class="sourceLine" id="cb7-10" title="10">  <span class="co">// jest-worker can handle both immediate results and thenables. If a</span></a>
<a class="sourceLine" id="cb7-11" title="11">  <span class="co">// thenable is returned, it will be await&#39;ed until it resolves.</span></a>
<a class="sourceLine" id="cb7-12" title="12">  <span class="cf">return</span> <span class="va">babel</span>.<span class="at">transformFileAsync</span>(filename).<span class="at">then</span>(result <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-13" title="13">    cache[filename] <span class="op">=</span> result<span class="op">;</span></a>
<a class="sourceLine" id="cb7-14" title="14"></a>
<a class="sourceLine" id="cb7-15" title="15">    <span class="cf">return</span> result<span class="op">;</span></a>
<a class="sourceLine" id="cb7-16" title="16">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-17" title="17"><span class="op">}</span></a></code></pre></div>
</body>
</html>
